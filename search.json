[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dashboard",
    "section": "",
    "text": "import {dashboard} from \"@cobus/dashboard-badges\"\n\n{\n  const ts = d3.format(\",\");\n\n  let badges = [];\n  badges.push({stat: ts(counts[0].innovation), description: \"Innovations\", backColor: \"red\"});\n\n  return dashboard({columns: 2, badges});\n}\nviewof min_year = Inputs.range(\n  [1970, 2020],\n  {value: 1970, step: 1, label: \"year (min):\"}\n)\nviewof max_year = Inputs.range(\n  [1971, 2021],\n  {value: 2021, step: 1, label: \"year (max):\"}\n)\n\n\n\n// viewof codes = Inputs.select(sni_options.map((d) =&gt; d),\n//   {label: 'SNI2002',\n//     format: (t) =&gt; `${t.code} ${t.desc}`,\n//     value: (t) =&gt; sni_options.find((t) =&gt; t.code == \"01\"),\n//     multiple: true\n//   })\n\n// str_codes = (codes.length === 0) ? \"\": (codes.length == 1)  ? ` and prod_code like \"${codes[0].code}%\"` : ` and ( ${codes.map((d) =&gt; `prod_code like \"${d.code}%\"`).join(' OR ')} ) `\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTimelineSNI2002 - experimentalData\n\n\n\n\nPlot.plot({\n    x: {\n    label: \"Year of commercialization\",\n    tickformat: k,\n  },\n  y:{\n    label: \"Number of innovations\",\n    grid: true\n  },\n    color: {legend: true},\n    marks: [\n      Plot.ruleY([0, 160]),\n\n      Plot.lineY(timeline_data, {x: \"year\", y:'value', stroke:'label'}, ),\n      Plot.ruleX(timeline_data, Plot.pointerX({py: \"value\", x: \"year\", stroke: 'red', format: k})),\n    Plot.tip(timeline_data, Plot.pointer({\n      x: \"year\",\n      y: \"value\",\n      title: (d) =&gt; `${d.label}: ${d.value}\\nYear: ${k(d.year)}`\n    }))\n\n            ],\n\n})\n\n\n\n\n\n\n\nPlot.plot({\n    x: {\n    label: \"Year of commercialization\",\n    tickformat: k,\n  },\n  y:{\n    label: \"Number of innovations within SNI 2-digit group\",\n    grid: true\n  },\n    color: {legend: true},\n    marks: [\n      Plot.ruleY([0, 160]),\n\n      Plot.areaY(prodtime_data,\n      Plot.stackY({\n        x: \"year\",\n        y:'value',\n        fill:'label',\n        title: (d) =&gt; `${d.label}\\n${k(d.year)} -- ${d.value} innovations`}, ),\n),\n      Plot.ruleX(prodtime_data, Plot.pointerX({py: \"value\", x: \"year\", stroke: 'red', format: k})),\n\n\n            ],\n            style: {\n              pointerEvents: 'all'\n            },\n                color: {\n      legend: true,\n      columns: \"110px\",\n      width: 640\n    }\n\n\n})\n\n\n\n\n\n\n\n\n\n\n\nviewof zoom = ZoomBurst(hi)\n\nzoom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nraw_tree = database.sql`SELECT distinct parent, name, tooltip from (SELECT \"SNI\" as parent, substr(prod_code,1,2) as name, \"\" as tooltip from innovation where year &gt;= ${min_year} and year &lt;= ${max_year} UNION ALL SELECT substr(prod_code,1,2) as parent, substr(prod_code,1,3) as name, \"\" as tooltip from innovation where year &gt;= ${min_year} and year &lt;= ${max_year} and year &gt;= ${min_year} and year &lt;= ${max_year} UNION ALL SELECT substr(prod_code,1,3) as parent, substr(prod_code,1,4) as name, \"\" as tooltip from innovation where year &gt;= ${min_year} and year &lt;= ${max_year} UNION ALL SELECT substr(prod_code,1,4) as parent, substr(prod_code,1,5) as name, \"\" as tooltip from innovation where year &gt;= ${min_year} and year &lt;= ${max_year} ) where name is not NULL and parent is not NULL and name != \"\" and parent != \"\" and name != parent  UNION ALL SELECT NULL as parent, \"SNI\" as name, \"\" as tooltip  UNION ALL SELECT prod_code as parent, id as name, \"Innovation: \" || id || \"\\n\" || \"Name: \" || coalesce(name_sv, \"[Unnamed]\" ) || \"\\n\" || desc_sv as tooltip from innovation where  year &gt;= ${min_year} and year &lt;= ${max_year} and prod_code is not NULL and prod_code != \"\" order by parent, name`\n\ntree = raw_tree.map((r) =&gt; ({\n  parent: r.parent,\n  name: r.name,\n  tooltip: get_sni_name(r.tooltip)\n}))\n\n\nhi = d3.stratify().id((d) =&gt; d.name).parentId((d) =&gt; d.parent)(tree);\n\nb = hi.sum((d) =&gt; 1 ? d.tooltip.substring(0,12) === \"Innovation: \" : 0).sort((a, b) =&gt; a.value + b.value);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInnovationArticleEntity\n\n\n\ninnovation = database.sql`Select * from innovation`;\n\nInputs.table(innovation)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\narticle = database.sql`Select * from article`;\n\nInputs.table(article)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nentity = database.sql`Select * from entity`;\n\nInputs.table(entity)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconsole.log('Loading data')\n\n\n\n\n\n\n\ndatabase = FileAttachment(\"SWINNO.UDIT.sqlite3\").sqlite()\nsni_options = await FileAttachment(\"sni2002.csv\").csv({typed: false})\nfunction k(d) {\n  return Number(d3.utcFormat('%Y')(d)) +1\n}\nfl = d3.format('.1f')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntimeline = database.sql`SELECT count(*) as count, year, \"Innovations\" as label from innovation where year &gt;= ${min_year} and year &lt;= ${max_year} group by year UNION ALL SELECT count(*) as count, year, \"Patented innovations\" as label from innovation where year &gt;= ${min_year} and year &lt;= ${max_year} and patented group by year `;\n\n\ncounts = database.sql`SELECT count(distinct i.id) as innovation, count(distinct a.id) as article, count(distinct e.id) as entity from innovation as i left outer join innovation_entity as ie on i.id == ie.innovation_id left outer join entity as e on ie.entity_id == e.id left outer join innovation_article as ia on i.id == ia.innovation_id left outer join article as a on ia.article_id == a.id where i.year &gt;= ${min_year} and i.year &lt;= ${max_year};`\n\n\ntimeline_data = timeline.map( (r) =&gt; ({\n  year: new Date(r.year, 0, 1),\n  label: r.label,\n  value: r.count,\n}))\n\n\ntimeline_prod = database.sql`select count(*) as count, year, substr(prod_code,1,2) as label from innovation where year between ${min_year} and ${max_year} and label in (\"31\", \"25\", \"30\", \"24\", \"28\", \"32\", \"72\", \"33\", \"29\" ) group by year, label UNION ALL select count(*) as count, year, \"Other\" as label from innovation where year between ${min_year} and ${max_year} and substr(prod_code,1,2) not in (\"31\", \"25\", \"30\", \"24\", \"28\", \"32\", \"72\", \"33\", \"29\") group by year `;\n\n\n\nfunction fill_in_zero_timestamps(data){\n  let result = [];\n  let labels = [\"31\", \"25\", \"30\", \"24\", \"28\", \"32\", \"72\", \"33\", \"29\", \"Other\"]\n  for (let year = min_year; year &lt;= max_year; year++){\n    labels.forEach((label) =&gt; {\n      let value = data.find((t) =&gt; t.year == year && t.label == label, false)\n        if (value != undefined){\n          result.push({\n            year: new Date(year, 0, 1),\n            label: label,\n            count: value.count\n            });\n        } else {\n          result.push({\n            year: new Date(year, 0, 1),\n            label: label,\n            count: 0\n        })\n        }\n        })\n\n    }\n\n  return result;\n  }\n\nprodtime_data_prep = fill_in_zero_timestamps(timeline_prod)\n\nfunction get_sni_name(code){\n  if ((code == \"Other\") || (code == \"SNI\") || (code.length &gt; 5)){\n    return code\n  }\n  console.log(code)\n\n  var result = sni_options.find((t) =&gt; t.code == code)\n\n  if (result == undefined){\n    return code\n   }\n\n  return `${code}: ${result.desc}`\n}\n\nprodtime_data = prodtime_data_prep.map( (r) =&gt; ({\n  year: r.year,\n  label: get_sni_name(r.label),\n  value: r.count,\n}))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ZoomBurst(hierarchy, {\n  height = 600,\n  width = 600,\n} = {}) {\n\n\n  // Specify the chart’s dimensions.\n  const radius = width / 6;\n\n  // // Create the color scale.\n  // const color = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, data.children.length + 1));\n  // const color = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, 100 + 1));\n\n  const color = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, hierarchy.children.length + 1));\n\n\n  const root = d3.partition()\n      .size([2 * Math.PI, hierarchy.height + 1])\n    (hierarchy);\n  root.each(d =&gt; d.current = d);\n\n  // Create the arc generator.\n  const arc = d3.arc()\n      .startAngle(d =&gt; d.x0)\n      .endAngle(d =&gt; d.x1)\n      .padAngle(d =&gt; Math.min((d.x1 - d.x0) / 2, 0.005))\n      .padRadius(radius * 1.5)\n      .innerRadius(d =&gt; d.y0 * radius)\n      .outerRadius(d =&gt; Math.max(d.y0 * radius, d.y1 * radius - 1))\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2, width * 1 , width])\n      .style(\"font\", \"10px sans-serif\");\n\n  // Append the arcs.\n  const path = svg.append(\"g\")\n    .selectAll(\"path\")\n    .data(root.descendants().slice(1))\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; { while (d.depth &gt;= 1) d = d.parent; return color(d.data.name); })\n      .attr(\"fill-opacity\", d =&gt; arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0)\n      .attr(\"pointer-events\", d =&gt; arcVisible(d.current) ? \"auto\" : \"none\")\n\n      .attr(\"d\", d =&gt; arc(d.current));\n\n  // Make them clickable if they have children.\n  path.filter(d =&gt; d.children)\n      .style(\"cursor\", \"pointer\")\n      .on(\"click\", clicked);\n\n  const format = d3.format(\",d\");\n  path.append(\"title\")\n      .text(d =&gt; `SNI ${d.data.name}\\nInnovations: ${format(d.value)}\\nParent: ${d.data.parent}\\n${d.data.tooltip}`);\n\n    // value: teams.find((t) =&gt; t.name === \"Warriors\")\n\n\n  const label = svg.append(\"g\")\n      .attr(\"pointer-events\", \"none\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"user-select\", \"none\")\n    .selectAll(\"text\")\n    .data(root.descendants().slice(1))\n    .join(\"text\")\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"fill-opacity\", d =&gt; +labelVisible(d.current))\n      .attr(\"transform\", d =&gt; labelTransform(d.current))\n      .text(d =&gt; d.data.name);\n\n  const parent = svg.append(\"circle\")\n      .datum(root)\n      .attr(\"r\", radius)\n      .attr(\"fill\", \"none\")\n      .attr(\"pointer-events\", \"all\")\n      .on(\"click\", clicked);\n\n  // Handle zoom on click.\n  function clicked(event, p) {\n    parent.datum(p.parent || root);\n\n    root.each(d =&gt; d.target = {\n      x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,\n      x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,\n      y0: Math.max(0, d.y0 - p.depth),\n      y1: Math.max(0, d.y1 - p.depth)\n    });\n\n\n\n    const t = svg.transition().duration(750);\n\n    // Transition the data on all arcs, even the ones that aren’t visible,\n    // so that if this transition is interrupted, entering arcs will start\n    // the next transition from the desired position.\n    path.transition(t)\n        .tween(\"data\", d =&gt; {\n          const i = d3.interpolate(d.current, d.target);\n          return t =&gt; d.current = i(t);\n        })\n      .filter(function(d) {\n        return +this.getAttribute(\"fill-opacity\") || arcVisible(d.target);\n      })\n        .attr(\"fill-opacity\", d =&gt; arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0)\n        .attr(\"pointer-events\", d =&gt; arcVisible(d.target) ? \"auto\" : \"none\")\n\n        .attrTween(\"d\", d =&gt; () =&gt; arc(d.current));\n\n    label.filter(function(d) {\n        return +this.getAttribute(\"fill-opacity\") || labelVisible(d.target);\n      }).transition(t)\n        .attr(\"fill-opacity\", d =&gt; +labelVisible(d.target))\n        .attrTween(\"transform\", d =&gt; () =&gt; labelTransform(d.current));\n  }\n\n  function arcVisible(d) {\n    return d.y1 &lt;= 3 && d.y0 &gt;= 1 && d.x1 &gt; d.x0;\n  }\n\n  function labelVisible(d) {\n    return d.y1 &lt;= 3 && d.y0 &gt;= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) &gt; 0.03;\n  }\n\n  function labelTransform(d) {\n    const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;\n    const y = (d.y0 + d.y1) / 2 * radius;\n    return `rotate(${x - 90}) translate(${y},0) rotate(${x &lt; 180 ? 0 : 180})`;\n  }\n\n  return svg.node();\n}\n\n\n\n\n\n\n\nfunction HeatMap(raw_data, title1, title2, caption,{\n  height = 600,\n  width = 600,\n  color_scheme = \"PiYG\",\n} = {}) {\n\nconst clean_data = raw_data.map((row) =&gt; ({\n  c1: row.c1 ? row.c1 : \"N/A\",\n  c2: row.c2 ? row.c2 : \"N/A\",\n  value: row.value\n}));\n\n\nconst chart = Plot.plot({\n  caption: caption,\n  height: 250,\n  width: 250,\n  padding: 0,\n  grid: true,\n  x: {axis: \"both\", label: title1},\n  y: {axis:\"both\", label: title2},\n    color: {scheme: color_scheme},\n  marks: [\n    Plot.cell(clean_data, {x:\"c1\", y:\"c2\", fill:\"value\", inset: 0.5}),\n    Plot.text(clean_data, {x:\"c1\", y:\"c2\", text:\"value\", fill: 'black',\n    title:(d) =&gt; `${title1}: ${d.c1}\\n${title2}: ${d.c2}\\n${d.value}`}),\n\n    ]\n});\n\nreturn chart\n}"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "An experimental implementation of a Dashboard for SWINNO"
  }
]